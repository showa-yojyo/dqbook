<?xml version="1.0" encoding="UTF-8"?>

<section id="dq6.message"><?dbhtml filename="dq6_message.html" ?>
<title>メッセージ解析</title>
<indexterm id="term.dq6.message"><primary>メッセージ</primary><secondary>DQ6</secondary></indexterm>

<section id="dq6.message.hack">
<title>解析手順</title>
<para>
	この文書では人々・動物・魔物の台詞やナレーション等の
	「大きいフォントを用いて表示するテキスト」全般の解析手段の検討および実践について述べる。
</para>

<section id="dq6.message.hack.amateur">
<title>素人の方法</title>
<para>
	&dq6_1995; で初登場した機能「おもいだす」「わすれる」をうまく利用して、メモリ Diff サーチを行う。
	これにより、セリフ・メッセージの内容と ID の対応表を手作業で作ることが可能だと考える
	（実際可能であった）。以下のような都合のよい仮定の下、サーチに励む：
</para>
<itemizedlist>
	<listitem>
		<para>
			「おもいだす」用のデータ格納領域が存在する
		</para>
	</listitem>
	<listitem>
		<para>
			そこには「おもいだす」の記憶リスト「１つめ」「２つめ」に対応するデータが直列している
		</para>
	</listitem>
	<listitem>
		<para>
			ゲームをプレイした感じから、メッセージは ID で表現されている
		</para>
	</listitem>
	<listitem>
		<para>
			メッセージ ID は <literal>2</literal> バイト 長である
		</para>
	</listitem>
</itemizedlist>
<para>
	長い時間とかなりの忍耐を要するが、以下のことが判明する。
	なお、ここで紹介した素人の方法はお奨めできるものではないことを最後に断っておく。
</para>
<itemizedlist>
	<listitem>
		<para>
			ID と セリフ・メッセージの対応
		</para>
	</listitem>
	<listitem>
		<para>
			セリフ・メッセージのおおまかな総数
		</para>
	</listitem>
</itemizedlist>
</section> <!-- dq6.message.hack.amateur -->

<section id="dq6.message.hack.pro">
<title>達人の方法</title>
<para>
	GSD さえあれば、特定のセリフまたはメッセージと ID の対応がわかればよい。
	憶えておく対応は一つでいい。
	以下、記者の実体験（というより、達人の追体験か）を説明する。
</para>
<para>
	例えば、ダーマの広間にいる熟練度を教える婆さんのセリフのしょっぱなの ID は <literal>#$199F</literal> だ。
	この婆さんに話しかけるや否や、<literal>#$199F</literal> になっているメモリアドレスをサーチする。
	ラッキーなことに、<literal>3</literal> つ程度
	(<varname>$7E3EEC</varname>, <varname>$7E5998</varname>, <varname>$7FB0AC</varname>) しかヒットしない。
	<literal>$7F</literal> から始まるのはうさんくさいので、候補から除外する。
	エミュレータを GSD に切り替え、残り二つのアドレスを Read タイプの Break Point で監視する。
	すると、<varname>$7E5998</varname> のほうで有力な処理が見つかる：
</para>
<programlisting>
$C0/2B69 AD 98 59    LDA $5998  [$7E:5998]   A:0000 X:0051 Y:FFFF D:0000 DB:7E S:083B P:envmxdIZc ..
$C0/2B72 AD 98 59    LDA $5998  [$7E:5998]   A:0007 X:0051 Y:FFFF D:0000 DB:7E S:083B P:envmxdIzc ..
$C6/E0E1 AD 98 59    LDA $5998  [$7E:5998]   A:0001 X:0003 Y:0018 D:0000 DB:7E S:083A P:envmxdIZC ..
</programlisting>
<para>
	<varname>$C02B69</varname>, <varname>$C02B72</varname> がお互いに近いところにあるが、
	これは一つのサブルーチンの中にある命令だと考えるのが自然だ。
	ではこのサブルーチン全体のアセンブリコードを詳しく見てみよう。
</para>

<section id="dq6.message.hack.pro.location">
<title>メッセージ ID からメッセージデータ位置を特定するルーチン</title>
<para>
	このサブルーチンは大きく分けて二つのことを行っている。
	その境目となるのが <varname>$C02BB4</varname> だ。
	アセンブリコードをつぶさに整理していくと、プログラムが
	<varname>$C02BB4</varname> に到達する時点で満たされる条件は、次のようになっている：
</para>
<itemizedlist>
	<listitem>
		<para>
			<varname>$7E5998</varname> にメッセージ ID が格納 (<literal>2</literal> バイト) 
		</para>
	</listitem>
	<listitem>
		<para>
			<varname>$7E5A1E</varname> にメッセージ ID の下位3ビットが格納
		</para>
	</listitem>
	<listitem>
		<para>
			<varname>$A0</varname>-<varname>$A3</varname> には、アドレスらしきデータが格納 (<literal>3</literal> バイト + <literal>#$00</literal>); <varname>$F7175B</varname> 以上の値だ
		</para>
	</listitem>
	<listitem>
		<para>
			<varname>$A4</varname> には、<varname>$C02BCC</varname> - <varname>$C02BD3</varname> にある <literal>1</literal> バイト の値のどれかが格納されている
		</para>
	</listitem>
	<listitem>
		<para>
			<varname>$A5</varname> には <literal>#$00</literal> が格納
		</para>
	</listitem>
</itemizedlist>
<programlisting>
C0/2B69:    AD9859      LDA $5998           // $7E5998 にメッセージ ID が格納されている
C0/2B6C:    290700      AND #$0007
C0/2B6F:    8D1E5A      STA $5A1E           $7E5A1E = メッセージ ID &amp; 0007h
C0/2B72:    AD9859      LDA $5998
C0/2B75:    4A          LSR A
C0/2B76:    4A          LSR A
C0/2B77:    4A          LSR A
C0/2B78:    48          PHA 
C0/2B79:    0A          ASL A
C0/2B7A:    6301        ADC $01,S
C0/2B7C:    AA          TAX                 x1 = メッセージ ID の上位13bit
// x1 は C15BB5 からのオフセットを意味する
// 8 個の連続した ID が一つのアドレスを見ているのがわかる
C0/2B7D:    68          PLA 
C0/2B7E:    BFB55BC1    LDA $C15BB5,X
C0/2B82:    85A0        STA $A0             $A0 = $(C15BB5 + x1);
// $A0-$A1: something data
C0/2B84:    290700      AND #$0007
C0/2B87:    DA          PHX
// x2: something data from C15BB5,X の下位 3bit
C0/2B88:    AA          TAX                 x2 = $(C15BB5 + x1) &amp; 0007h
C0/2B89:    BFCC2BC0    LDA $C02BCC,X
C0/2B8D:    29FF00      AND #$00FF          // マスクビット取得
C0/2B90:    85A4        STA $A4             $A4 = $(C02BCC + x2) &amp; 00FFh
// $A4: mask from C02BCC,X
// $A5: 00h
C0/2B92:    FA          PLX
C0/2B93:    BFB75BC1    LDA $C15BB7,X
C0/2B97:    29FF00      AND #$00FF
C0/2B9A:    4A          LSR A               // LSR と ROR が入り乱れているわけだが
C0/2B9B:    66A0        ROR $A0             // carry bit を介して $C15BB7,X の
C0/2B9D:    4A          LSR A               // 下位 3 ビットが $A1 の上位 3 ビットになる
C0/2B9E:    66A0        ROR $A0             // 
C0/2BA0:    4A          LSR A               // 
C0/2BA1:    66A0        ROR $A0
C0/2BA3:    85A2        STA $A2             $A0 = cast&lt;3byte&gt;($(C15BB5 + x1)) &gt;&gt; 3;
C0/2BA5:    A5A0        LDA $A0
C0/2BA7:    18          CLC 
C0/2BA8:    695B17      ADC #$175B
C0/2BAB:    85A0        STA $A0
C0/2BAD:    A5A2        LDA $A2
C0/2BAF:    69F700      ADC #$00F7
C0/2BB2:    85A2        STA $A2             $A0 += 00F7175Bh;
// $A0 に何らかのアドレス値がセットされた
</programlisting>
<para>
	ここで <varname>$C15BB5</varname> から格納されているデータを ROM イメージファイルからダンプしてみる。
	この時点ではメッセージの個数がわからないため、データ領域の終端位置もわからない。
	しかし、いざダンプリストを見ると、データが単調増加しているではないか。
	これに注目すれば自ずと終端位置がわかる。すなわち、
	データ一個につき、メッセージ <literal>8</literal> 個が対応しているので、
	最後のメッセージ ID の候補もあたりがつけられる。
</para>
<programlisting>
C1/5BB5:    070000  // ID 0000h - 0007h に対応するデータ
C1/5BB8:    A60200  // ID 0008h - 000Fh
C1/5BBB:    D90600  // ID 0010h - 0017h
// 3 byte の数値が昇順に配列されている……
C1/65E1:    986F23  // ID 1B20h - 1B27h
C1/65E4:    817823  // ID 1B28h - 1B30h
C1/65E7:    000060  // ここからは明らかに異質なデータなので除外
// ...
</programlisting>
<para>
	このサブルーチンの後半で、別のサブルーチンを複数回呼び出している。
	これにより、<varname>$7E5A1E</varname> の意味が「何らかの処理の反復回数」と判明する。
	このループ＋サブルーチン <varname>$C02BD4</varname> がメッセージデータの取得部の核心だ。
</para>
<programlisting>
C0/2BB4:    AD1E5A      LDA $5A1E           while($7E5A1E){  // == メッセージ ID &amp; 0007h;
C0/2BB7:    F012        BEQ $2BCB               do{
C0/2BB9:    20D42B      JSR $2BD4                   ☆サブルーチン呼び出し☆
C0/2BBC:    C9AC00      CMP #$00AC                  if(a == 00ACh)  // delimeter の役を果たす
C0/2BBF:    F005        BEQ $2BC6                       break;
C0/2BC1:    C9AE00      CMP #$00AE
C0/2BC4:    D0F3        BNE $2BB9               }while(a != 0x00AE);
C0/2BC6:    CE1E5A      DEC $5A1E               --$7E5A1E;
C0/2BC9:    80E9        BRA $2BB4           }
C0/2BCB:    60          RTS                 return;
</programlisting>
</section> <!-- dq6.message.hack.pro.location -->

<section id="dq6.message.hack.pro.decode">
<title>文字コード取得ルーチン</title>
<para>
	サブルーチン <varname>$C02BD4</varname> も二つのパートにわかれているが、
	今興味があるのは後半部分 <varname>$C02BFA</varname> から <varname>$C02C26</varname> までだ。
	アセンブリコードを以下に示す：
</para>
<para>
	ハフマン復号というアルゴリズムにより、文字コードをハフマンツリーから取得している。
	と、これはあるお方の受け売りだが。
	とにかく、ルーチンとしては <varname>$A0</varname> が示すアドレスに格納されている値から文字コード (<literal>2</literal> バイト) を
	復号し、アキュームレータに格納する。さらに、<varname>$A0</varname> の示すアドレスも必要に応じてインクリメントする
	……というのが、このサブルーチンの主目的のようだ。
</para>
<para>
	<varname>$A0</varname> に格納されているアドレスに格納されているデータは、
	「文字コードの配列を圧縮したもの」だとイメージすればよい。
	圧縮してある故、各データの格納位置がビット単位で指定されていなければならず、
	その「ベース」アドレスが <varname>$A0</varname>-<varname>$A3</varname> に、
	オフセット・ビットを示す値が <varname>$A4</varname> にストアされているのだと、ここで理解できる。
	前項で触れたが、<varname>$A0</varname> の初期値はメッセージ ID の下位 <literal>3</literal> ビットから決まる、
	配列 <varname>$C02BBC</varname> のどれかとなる。
</para>
<programlisting>
C0/2BCC:    01   // == 1 &lt;&lt; 0
C0/2BCD:    02   // == 1 &lt;&lt; 1
C0/2BCE:    04   // == 1 &lt;&lt; 2
C0/2BCF:    08   // == 1 &lt;&lt; 3
C0/2BD0:    10   // == 1 &lt;&lt; 4
C0/2BD1:    20   // == 1 &lt;&lt; 5
C0/2BD2:    40   // == 1 &lt;&lt; 6
C0/2BD3:    80   // == 1 &lt;&lt; 7
</programlisting>
</section> <!-- dq6.message.hack.pro.decode -->

<section id="dq6.message.hack.pro.dog">
<title>照合</title>
<para>
	前項で見たアキュームレータの値が、本当に文字コードを表すものかを確認すべく、
	アセンブリコードを見るのではなく、デバッガの力を借りて検証する。
	上記サブルーチンの呼び出し元に遡って、Exec ブレークポイントを一個セットする。
	ここでセリフと文字とコードの対応がわかりやすいキャラに話しかけ、
	文字一個一個をウィンドウにアウトプットするたびに、
	ブレークポイントに到達すれば OK だ。
</para>
<para>
	記者は、イヌに話しかけた。
	<literal>＊「わんっ わんっ わんっ！</literal>
	という、お誂え向けのセリフを持つイヌがモンストルにいるのだ。
	以下、そのトレースである：
</para>
<programlisting>
$C0/2C92 8D B2 59    STA $59B2  [$7E:59B2]   A:0511     不明
$C0/2C92 8D B2 59    STA $59B2  [$7E:59B2]   A:0577     不明
$C0/2C92 8D B2 59    STA $59B2  [$7E:59B2]   A:00AB     不明
$C0/2C92 8D B2 59    STA $59B2  [$7E:59B2]   A:0523     「わ」
$C0/2C92 8D B2 59    STA $59B2  [$7E:59B2]   A:04F7     「ん」
$C0/2C92 8D B2 59    STA $59B2  [$7E:59B2]   A:0620     「っ」
$C0/2C92 8D B2 59    STA $59B2  [$7E:59B2]   A:0200     スペース
$C0/2C92 8D B2 59    STA $59B2  [$7E:59B2]   A:0523     「わ」
$C0/2C92 8D B2 59    STA $59B2  [$7E:59B2]   A:04F7     「ん」
$C0/2C92 8D B2 59    STA $59B2  [$7E:59B2]   A:0620     「っ」
$C0/2C92 8D B2 59    STA $59B2  [$7E:59B2]   A:0200     スペース
$C0/2C92 8D B2 59    STA $59B2  [$7E:59B2]   A:0523     「わ」
$C0/2C92 8D B2 59    STA $59B2  [$7E:59B2]   A:04F7     「ん」
$C0/2C92 8D B2 59    STA $59B2  [$7E:59B2]   A:0620     「っ」
$C0/2C92 8D B2 59    STA $59B2  [$7E:59B2]   A:0551     「！」
$C0/2C92 8D B2 59    STA $59B2  [$7E:59B2]   A:00AC     00ACh は終端を意味する？
</programlisting>
<para>「わ」「ん」「っ」を見ると、
	<varname>A</varname> レジスタの値と表示される文字が一対一対応している。
	これにより、アキュームレータの値はコードと断定してよいことがわかる。
	念を入れて、他の人物に話しかけてコードと表示される文字の対応をもう少し調べてもよい。
</para>
<para>
	ここで、ドラクエビューア <xref linkend="dqref.url2"/> が出力する
	<filename>SFC_DQ6gra.bmp</filename> のフォントテーブルと、「わ」「ん」等の位置＝インデックスを照合してみる。
</para>
<table id="table.dq6.message.dog" class="lighttable">
	<caption>わんっ！</caption>
	<thead>
		<tr><th>文字</th><th>A</th><th>BMP</th></tr>
	</thead>
	<tbody>
		<tr><td>わ</td><td><literal>#$0523</literal></td><td><literal>#$0322</literal></td></tr>
		<tr><td>ん</td><td><literal>#$04F7</literal></td><td><literal>#$02F6</literal></td></tr>
		<tr><td>っ</td><td><literal>#$0620</literal></td><td><literal>#$041F</literal></td></tr>
		<tr><td>！</td><td><literal>#$0551</literal></td><td><literal>#$0350</literal></td></tr>
	</tbody>
</table>
<para>
	どの文字も差が定数 <literal>#$0201</literal> になる。
	デコードルーチンはこのフォントテーブルへのインデックス値を直接取得していると考えてよい。
	定数分の差は、何か別のデータがフォントの直前にあり、
	そこから生じたのものだと、とりあえず予想しておく。
</para>
</section> <!-- dq6.message.hack.pro.dog -->

<section id="dq6.message.hack.pro.reproduce">
<title>メッセージデータ再現</title>
<para>
	今まで見てきたサブルーチンおよびフォントテーブルを C 言語で再現して、
	&dq6_1995; に存在するすべてのメッセージデータを
	ROM イメージファイルから抽出する。
</para>
<para>
	最大の難関は、文字コードから文字そのものに変換する仕組みの実装だが、
	ここは偉大な先人の成果を再利用させていただくことで解決する。
	dq_analyzer <xref linkend="dqref.url1"/> に同梱されている
	<filename>dq6decode.c</filename> の「メッセージ文字列用」配列を、
	これから書くソースファイルにコピー＆ペーストする。
</para>
<para>
	あとは上で述べたサブルーチンを 65816 コードではなく、C 言語で書き直せばよい。
	それは、メッセージ ID からデータ格納位置を取得するコード、
	ハフマン復号をするコード等だ。
</para>
</section> <!-- dq6.message.hack.pro.reproduce -->
</section> <!-- dq6.message.hack.pro -->
</section> <!-- dq6.message.hack -->

<section id="dq6.message.download">
<title>ダウンロード</title>

<section id="dq6.message.download.source">
<title>ソースコード（不完全版）</title>
<para>
	<xref linkend="appendix.b" />
</para>
<para>
	達人の方法で述べたメッセージ解析手段を C 言語で表現したものだ。
	文字コード配列は dq_analyzer <xref linkend="dqref.url1"/> から
	取得したものを使うのがよいと判断したため、ここは空白になっている。
	「不完全」なのは、この一点のみだ（と信じている）。
</para>
<para>
	まったくの余談だが、解析作業当時（現在もだが）記者は自宅にネット環境がないため、
	dq_analyzer <xref linkend="dqref.url1"/> がいつの間にかメッセージ抽出を実装していたことを知らなかった。
	それ故、ドラクエビューア <xref linkend="dqref.url2"/> が出力する
	<filename>SFC_DQ6gra.bmp</filename> を見ながら、大フォント版文字配列を自前で書いてしまった過去がある。
	読者はこのようなおろかなことをしないように。
</para>
</section> <!-- dq6.message.download.source -->

<section id="dq6.message.download.data">
<title>データ</title>
<para>
	<xref linkend="appendix.b" />
</para>
</section> <!-- dq6.message.download.data -->
</section> <!-- dq6.message.download -->
</section> <!-- dq6.message -->
